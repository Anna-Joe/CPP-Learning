## 第一阶段 C++Primer 5th 学习笔记
[unsigned与signed](#unsigned与signed)    
[变量](#变量)   
[复合类型](#复合类型)   
[const限定符](#const限定符)   
[sizeof运算符](#sizeof运算符)   
[](#)   
### unsigned与signed
C++的基本数据类型：字符、布尔、整型、浮点    
- 字符型：位数与机器数相同
- 布尔型：0值为False，其他值为True      
- 整型：short《=int 《=long《=long long     
- 浮点型：float double
#### 除了布尔类型之外都有有符号类型和无符号类型的区别。
有符号型（默认）：有符号位，数字只占2^(该基本数据类型所占位数-1)位     
无符号型：没有符号位，数字占2^(该基本数据类型所占位数)位    
尤其要注意无符号型和有符号型的混合运算，会先把有符号型转化为无符号型，再进行计算。    

### 变量   
变量定义：类型说明符 变量名列表    
- 初始化和赋值：两个过程    
初始化是创建变量时赋予一个初始值。赋值是擦除当前的值，用新值代替。    
- 声明和定义   
声明使得名字为程序所知。定义负责创建与名字有关的实体。 
```c++
extern int i;//声明i
int i;//声明并定义i
extern int pi=3.1415926;//定义i
```

### 复合类型
- 指针   
指向某个对象的对象。   
 1.指针本身就是一个对象，允许对指针赋值和拷贝，并且在指针的生命周期内它可以指向不同的对象。   
 2.指针无须在定义时赋值。（如果没有赋值，就跟其他对象一样，指向一个不确定的值。）
 **建议初始化所有指针**

- void* 指针
一种特殊类型的指针，可以存放任意对象的地址。   
用法：拿它跟别的对象比较/作为函数的输入或输出/或者赋给另一个void* 指针。       
不能直接操作void* 指针所指向的对象，因为不知道它所指向的类型。    
 
- 引用（左值引用）   
某个对象的别名。（不存放对象）   
> 定义引用时，程序把引用和他的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用绑定到另一个对象，所以引用必须初始化。   
**引用不可以指向引用**

**有指向指针的引用，没有指向引用的指针。（指针只能指向对象，引用不是对象）**

### const限定符
- const修饰普通变量   
被修饰的变量一经初始化不可被修改。
- const修饰指针   
被const指针修饰的对象，不可以使用指针改变这个对象的值，对象可以自己改变自己。    
**常量对象的地址只能使用常量指针存放。**
- const修饰引用   
被const修饰的引用，引用与对象的绑定关系不改变（本来就不可变啊），对象是可以改变的。
-----
- 顶层const   
两种情况：1.被修饰的对象是常量（也就是说没什么意外大家都是顶层）。2.修饰对象的指针是常量指针（指针是常量）。
- 底层const
指针存放的是常量对象的地址（对象是常量）。   
当表达式里存在指针或引用的时候才会有底层const出现。     
-----
- constexpr常量表达式（c++11）   
值不会改变并且在编译过程中就能得到计算结果的表达式。   

### sizeof运算符
sizeof运算符返回**一条表达式**或**一个类型名字**所占的字节数。
- 满足右结合律（？？？）
- sizeof运算符的结果部分地依赖于其作用的类型：
  - 对引用执行sizeof计算得到的结果是 **被引用对象** 所占的空间大小。
  - 对指针执行sizeof计算得到指针本身所占空间大小。
  - 对数组执行sizeof运算得到整个数组所占的空间大小。（等价于依次计算数组每个元素的sizeof）
  - 对string对象或vector对象执行sizeof运算只得到固定部分的大小，不会计算对象中的元素占了多少空间。（capability？？不是size？？）  
- sizeof返回的是一个常量表达式，可以用sizeof的结果来声明数组长度。

### 特殊用途语言特性
- 默认实参
  - 在函数的很多次调用中被赋予一个相同的值的参数，可以作为函数的默认实参（default argument）。
  - 调用含有默认实参的函数时，可以包含这个实参，也可以省略该实参。（包含则表示给这个参数赋值，省略表示使用该参数的默认值）。
  - 一旦某个形参被赋予了默认值，它后面所有的形参都必须有默认值。
  - 程序中多次声明函数是合法的，但是同一个参数只能有一个默认值，后面的多次声明可以给没有默认值的参数赋值，但是不能给已有默认值的参数赋值。

- 内联函数 inline
内联函数就是将函数在每个调用点上展开。内联函数适用于优化规模较小，流程直接，调用频繁的函数。

- constexpr函数
计算常量表达式，但他的返回值不一定是常量。
**constexpr函数和内联函数通常放在头文件内**

### 调试帮助
- assert预处理宏
`assert(expr);//用一个布尔表达式作为它的条件`
首先对expr求值，如果表达式为假，assert输出信息并终止程序的执行。如果表达式为真，什么也不做。

- NDEBUG
如果没有定义NDEBUG，将执行#ifndef之间的代码；如果定义了NDEBUG，这些代码将被忽略。
```C++
#ifndef NDEBUG
//中间是需要测试的代码
#endif
```


## 第二阶段 （浙大翁恺老师）C++视频课+github笔记 查缺补漏

## 第三阶段 （陈越版本）数据结构

 [是否使用typedef定义结构体的区别](https://github.com/Anna-Joe/CplusCodingProgress/blob/master/%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8typedef%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB.md)

 [关于树形结构的小结](https://github.com/Anna-Joe/CplusCodingProgress/blob/master/%E5%85%B3%E4%BA%8E%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%9A%84%E5%B0%8F%E7%BB%93.md)
